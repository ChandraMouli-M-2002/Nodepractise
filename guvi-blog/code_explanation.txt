ğŸ”¹ What does parse mean in English?

Parse = to read, break down, and convert data into a format that the program can understand.

In programming, raw data usually comes as text (string), and parsing means turning it into a structured format (like an object or array).

ğŸ‘‰ Example (English):

Raw request body:
     
    email=mouli%40gmail.com&password=1234


After parsing:

      { email: "mouli@gmail.com", password: "1234" }


So parsing = translating raw data into usable data.





 ğŸ”¹ 1. bodyParser.json()

 * Parses JSON request bodies (like when you send data with fetch or Axios)

Example:

POST /user/login
Content-Type: application/json

{ "email": "mouli@gmail.com", "password": "1234" }

* Without this middleware: req.body would be undefined.
* With it:

  req.body = { email: "mouli@gmail.com", password: "1234" }



ğŸ”¹ 2. bodyParser.urlencoded({ extended: false })

Parses form submissions (application/x-www-form-urlencoded).

Example (HTML form):

<form method="POST" action="/user/login">
  <input name="email" value="mouli@gmail.com">
  <input name="password" value="1234">
  <button type="submit">Login</button>
</form>

* Browser sends:

email=mouli%40gmail.com&password=1234

* Middleware parses it into:

req.body = { email: "mouli@gmail.com", password: "1234" }

So together, bodyParser.json() and bodyParser.urlencoded() let your app handle API requests + form requests.



ğŸ”¹ 3. express.static(path.resolve('./public'))

Serves static files (CSS, JS, images) from the public folder.

Example:

You put public/style.css

Visiting http://localhost:8000/style.css â†’ Express sends that file directly.

Useful for frontend assets.




ğŸ”¹ 4. cookieParser()

app.use(cookieParser());
// When a request comes into your server, it may contain cookies in the HTTP header:

//By default, Express does not parse cookies.
//If you try req.cookies without cookie-parser, it will be undefined.

// With cookieParser() middleware:
// It runs on every request (because you used app.use).
// It parses the raw cookie string.
// It attaches the parsed cookies as a nice object to the request:
// req.cookies = {
//   Token: "abcd123",
//   theme: "dark"
// }


ğŸ”¹ 5. CheckForToken (your custom middleware)

Runs after cookieParser().

Purpose: check if a cookie named Token exists.

If found:

Verifies the JWT.

Attaches decoded user info to req.user.

If not found or invalid:

Simply calls next() (doesnâ€™t block).

So now inside your routes, you can do:

if (req.user) {
  console.log("Logged-in user:", req.user);
}


ğŸ”¹ Middleware Order (very important ğŸš¦)

In Express, order matters. For your app:

JSON body parsed

Form body parsed

Static files served

Cookies parsed

Token checked

Routes executed (/, /user, /blog)

Thatâ€™s why cookieParser() is before CheckForToken â†’ otherwise, req.cookies would be undefined.


Middleware is a function in Express that sits between the request and the response.
It can look at the request, modify it, stop it, or pass it to the next function using next().

ğŸ‘‰ Example to say in interview:
â€œIn Express, app.use(express.json()) is a middleware. It reads the raw request body and converts it into a JSON object so that we can use req.body directly.â€



ğŸ”¹ How file upload works (browser â†’ server)

In HTML a file input looks like:

<form action="/create" method="POST" enctype="multipart/form-data">
  <input type="text" name="title" />
  <input type="file" name="coverimage" accept="image/*" />
  <button type="submit">Upload</button>
</form>


enctype="multipart/form-data" is mandatory when sending files. It tells the browser to package the form as multiple parts (fields + files) rather than URL-encoding the whole body.

ğŸ”¹What multipart/form-data actually is

The HTTP request body is split into parts separated by a boundary string. Each part has its own headers (e.g., Content-Disposition, Content-Type) and body.

*Why this is necessary: URL encoding (application/x-www-form-urlencoded) is textual and cannot carry raw binary safely/efficiently and it treats the whole body as a single encoded string. multipart/form-data keeps file binary data as separate parts.

ğŸ”¹Why body-parser / express.json() wonâ€™t parse file uploads

* body-parser (and express.json() / express.urlencoded()) parse application/json or application/x-www-form-urlencoded. They do not parse multipart streams.

* Multipart is streamed: it contains file binary parts that must be parsed part-by-part. So you need a multipart parser middleware (multer, busboy, formidable, multiparty, etc.).

ğŸ”¹What Multer does (high level)

Multer is Express middleware that parses multipart/form-data requests.

It reads the incoming request stream, recognizes parts, and for each file part it:

Either writes the file to disk (diskStorage) or collects it into memory (memoryStorage) depending on the storage engine.

Adds metadata to the request object: req.file (single) or req.files (multiple).

Adds text fields to req.body.

Internally multer uses busboy
 to parse the streaming multipart body.